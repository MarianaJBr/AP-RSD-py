#####-----------------------------------------------------------------------------######
# This script contains the definition of r_obs and mu_obs in terms of the r_fid and mu_fid
# as described in Xu et al 2013 (MNRAS 431-2834-2860)
# it calculates the monopole and quadrupole from  the xi(r, mu) GSRSD output
# and applies the dilation through values for alpha and epsilon
#####-----------------------------------------------------------------------------######
# if the cosmology assumed (fiducial) is equal to the TRUE cosmology
# then alpha should be equal to 1 and epsilon = 0
# def alpha():
# D_a: angular distance
# alpha = (dist_ang/dist_ang_fid)**(2/3)*(H_fid/H)**(1/3)
# def epsilon():
# 1 + epsilon = ((H_fid/H)*(D_a_fid/D_a))**(1/3)
#####-----------------------------------------------------------------------------######
# Mariana Jaber.  Feb 2017



import numpy as np
from scipy.integrate import quadrature
from scipy.interpolate import interpolate
import sys, os
file_path = os.path.dirname(os.path.abspath(__file__))
print(file_path)
sys.path.insert(0, os.path.join(file_path, '..'))

#relative path using dropbox
datafiles_path = os.path.join(file_path, '../data-files/')

#path from mac
clpt_gsrsd_files_path = './../../../../codes/CLPT_GSRSD/data/'
#ecs mvm
#r_obs[:,i] = r_fid*alpha*np.sqrt((1+epsilon)**4.*mu_fid2[i] + (1.-mu_fid2[i])/(1+epsilon)**2.)
#mu_obs2 = 1./(1. + (1./mu_fid2-1)/(1+epsilon)**6.)

def rdil(rfid, mufid, alpha, epsilon):
    '''
    This function applies the AP dilation to the r coordinate
    We will feed this function with the list of r, mu coordinates
    and it will return the r dilated
    :param rfid: fiducial value for r (the one generated by GSRSD, etc.)
    :param mufid: fiducial valuem  for mu = cos(theta) (as generated by GSRSD)
    :param alpha: isotropic dilation AP factor
    :param epsilon: the other AP deformation factor
    :return: r_dilated
    '''
    mufid2 = mufid ** 2
    factor1 = alpha * rfid * (1 + epsilon) ** 2
    factor2 = mufid2 + (1 - mufid2) / (1 + epsilon) ** 6
    return factor1 * np.sqrt(factor2)


def mudil2(mufid, epsilon):
    '''
    We will feed this function with the list of  mu coordinate
    and it will return the mu dilated squared
    This function applies the AP dilation to the mu coordinate
    :param mufid: mu fiducial
    :param epsilon:
    :return: mu_dilated^2 = 1 / ((1-mufid^2)/mufid^2)/(1+epsilon)^6
    '''
    mufid2 = mufid ** 2
    factor1 = ((1 - mufid2) / mufid2) / (1 + epsilon) ** 6
    return 1 / (1 + factor1)


###
# now we need to get the data input from GSRD:
#

#xi2dGSRDfile = os.path.join(datafiles_path, 'xi_s_qso.txt_2d')
xi2dGSRDfile = os.path.join(clpt_gsrsd_files_path, 'xi_s_qso.txt_2d')
xi2dGSRD = np.loadtxt(xi2dGSRDfile)

#xipolesGSRDfile = os.path.join(datafiles_path,'xi_s_qso.txt')
xipolesGSRDfile = os.path.join(clpt_gsrsd_files_path,'xi_s_qso.txt')
xipolesGSRD = np.loadtxt(xipolesGSRDfile)

#data from mock
xipolesdatafile = os.path.join(datafiles_path,'EZ_QSO_mock_v1.3_NGC-SGC_0999.xi.mul')
xipolesdata = np.loadtxt(xipolesdatafile)



# model: from the 2-d GSRSD output:
xi2Ddata = xi2dGSRD.reshape(25, 64, 3)
r2DdataMatrix = xi2Ddata[:, :, 0]
mu2DdataMatrix = xi2Ddata[:, :, 1]
xi2DdataMatrix = xi2Ddata[:, :, 2]

r2Dto1d = r2DdataMatrix[:, 0]
mu2Dto1d = mu2DdataMatrix[0, :]

# data: from mock:
rmock = xipolesdata[:, 0]
xi0mock = xipolesdata[:, 1]
xi2mock = xipolesdata[:, 2]


# from r=36-156Mpc/h
r36t156model = r2Dto1d[4:20]
r36t156mock = rmock[4:20]

############################################################################
# we need to make this step before calling xi_poles function. We will use the interpolated
# function of xi_from_gsrd as model and then we will dilate the coordinates and see the change
# in the multipoles xi_model_0, xi_model_2


xirmuinterpoladora = interpolate.RectBivariateSpline(r2Dto1d, mu2Dto1d, xi2DdataMatrix,
                                                     kx=5, ky=5)


def xi_poles_integrand(mufid, rfid, alpha, epsilon, order):
    '''
    Given the mu and r arrays, and the alpha and epsilon values it calculates the
    dilated r_ap, mu_ap according to AP prescription. Then the Legendre polynomial for mu_ap
    is constructed. Next, the interpolating function is called and fed with r_ap, and mu_ap
    coordinates. Finally this returns the value for the interpolating function multiplied by
    by corresponding Legendre polynomial.
    '''
    rprime = rdil(rfid, mufid, alpha, epsilon)
    muprime2 = mudil2(mufid, epsilon)
    muprime = np.sqrt(muprime2)

    if order == 0:
        Ll = 1.
    elif order == 2:
        Ll = (1. / 2.) * (3. * muprime2 - 1.)
    elif order == 4:
        Ll = (1. / 8.) * (35. * muprime2 ** 2 - 30. * muprime2 + 3.)
    else:
        raise ValueError('Invalid order for Legendre polynomial')

    xi = xirmuinterpoladora(rprime, muprime)

    return float(xi[0, 0]) * Ll


def xi_poles(rfid, alpha, epsilon, order):
    coeff = 2 * order + 1
    fn = xi_poles_integrand
    int, error = quadrature(fn, 0, 1,
                            tol=1.49e-8,
                            maxiter=100,
                            args=(rfid, alpha, epsilon, order),
                            vec_func=False)

    return coeff * int


## the output from this script is this vectorized function: vxi_poles(alpha, epsilon, l=0,2)
vxi_poles = np.vectorize(xi_poles, excluded=['alpha', 'epsilon', 'order'])

